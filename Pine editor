//@version=6
// FINAL COMPLETE VERSION - COPY FROM HERE
// Unified SMC + UT Bot + HMA + ORB + Institutional Sweep Strategy
// All bugs fixed, complete integration, Pine Script v6
strategy('Complete Unified Strategy', 'UnifiedStr', overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500)

//---------------------------------------------------------------------------------------------------------------------
// CONSTANTS
//---------------------------------------------------------------------------------------------------------------------
BULLISH_LEG = 1
BEARISH_LEG = 0
BULLISH = +1
BEARISH = -1
GREEN = #089981
RED = #F23645
BLUE = #2157f3
GRAY = #878b94

//---------------------------------------------------------------------------------------------------------------------
// INPUTS - SMART MONEY CONCEPTS
//---------------------------------------------------------------------------------------------------------------------
showTrendInput = input.bool(false, 'Color Candles', group='Smart Money Concepts')
showInternalsInput = input.bool(true, 'Show Internal Structure (BOS/CHoCH)', group='Smart Money Concepts')
showStructureInput = input.bool(true, 'Show Swing Structure (BOS/CHoCH)', group='Smart Money Concepts')
swingsLengthInput = input.int(50, 'Swing Points Length', group='Smart Money Concepts', minval=10)
internalLengthInput = input.int(5, 'Internal Structure Length', group='Smart Money Concepts', minval=3, maxval=20)
showInternalOrderBlocksInput = input.bool(true, 'Internal Order Blocks', group='Order Blocks')
showSwingOrderBlocksInput = input.bool(false, 'Swing Order Blocks', group='Order Blocks')
showSwingLabelsInput = input.bool(true, 'Show BOS/CHoCH Labels', group='Smart Money Concepts')

//---------------------------------------------------------------------------------------------------------------------
// INPUTS - UT BOT
//---------------------------------------------------------------------------------------------------------------------
utKeyValue = input.int(2, title="UT Key Value", group="UT Bot Settings")
utATRPeriod = input.int(1, title="UT ATR Period", group="UT Bot Settings")
utUseHeikinAshi = input.bool(false, title="Use Heikin Ashi", group="UT Bot Settings")

//---------------------------------------------------------------------------------------------------------------------
// INPUTS - HULL MA
//---------------------------------------------------------------------------------------------------------------------
hullPeriod = input.int(31, title="Hull MA Period", group="Hull MA Settings")

//---------------------------------------------------------------------------------------------------------------------
// INPUTS - ORB
//---------------------------------------------------------------------------------------------------------------------
orbTimeMax = input.int(5, title="ORB Total Time (minutes)", group="ORB Settings")
orbSession = input.session("1010-1015", title="ORB Session Time", group="ORB Settings")

//---------------------------------------------------------------------------------------------------------------------
// INPUTS - INSTITUTIONAL SWEEP
//---------------------------------------------------------------------------------------------------------------------
cooldownPeriod = input.int(10, title="Cooldown Period", minval=0, group="Sweep Settings")
showSwing = input.bool(true, title="Show Swings?", inline="s_1", group='Sweep Detection')
swingClr = input.color(color.new(color.black, 0), title='', inline="s_1", group='Sweep Detection')
bullWidth = input.int(1, title='Line Width:', group='Bullish Sweep')
bullStyle = input.string('Dashed', title='Line Style:', options=['Solid', 'Dotted', 'Dashed'], group='Bullish Sweep')
bullColor = input.color(color.new(color.teal, 0), title='Bullish Color:', group='Bullish Sweep')
bearWidth = input.int(1, title='Line Width:', group='Bearish Sweep')
bearStyle = input.string('Dashed', title='Line Style:', options=['Solid', 'Dotted', 'Dashed'], group='Bearish Sweep')
bearColor = input.color(color.new(color.maroon, 0), title='Bearish Color:', group='Bearish Sweep')

//---------------------------------------------------------------------------------------------------------------------
// DATA STRUCTURES
//---------------------------------------------------------------------------------------------------------------------
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime = time
    int barIndex = bar_index

type trend
    int bias

type orderBlock
    float barHigh
    float barLow
    int barTime
    int bias

//---------------------------------------------------------------------------------------------------------------------
// VARIABLES - SMC
//---------------------------------------------------------------------------------------------------------------------
var pivot swingHigh = pivot.new(na, na, false)
var pivot swingLow = pivot.new(na, na, false)
var pivot internalHigh = pivot.new(na, na, false)
var pivot internalLow = pivot.new(na, na, false)
var trend swingTrend = trend.new(0)
var trend internalTrend = trend.new(0)
var array<orderBlock> swingOrderBlocks = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes = array.new<box>()
var array<box> internalOrderBlocksBoxes = array.new<box>()
var array<float> parsedHighs = array.new<float>()
var array<float> parsedLows = array.new<float>()
var array<float> highs = array.new<float>()
var array<float> lows = array.new<float>()
var array<int> times = array.new<int>()

//---------------------------------------------------------------------------------------------------------------------
// VARIABLES - INSTITUTIONAL SWEEP
//---------------------------------------------------------------------------------------------------------------------
lbLeft = 20
lbRight = 20

var int bullSignalIndex = 0
var int bearSignalIndex = 0
var line bullLine = na
var line bearLine = na
var line highLine = na
var line lowLine = na
var label swingHighLbl = na
var label swingLowLbl = na
var label swingHighLblTxt = na
var label swingLowLblTxt = na
var float swingLowVal = na
var float swingHighVal = na
var int swingLowCounter = 0
var int swingHighCounter = 0
var bool isSwingLowCheck = false
var bool isSwingHighCheck = false
var bool stopPrintingLow = false
var bool stopPrintingHigh = false
var array<label> swingHighArr = array.new_label(0)
var array<label> swingHighTextArr = array.new_label(0)
var array<label> swingLowArr = array.new_label(0)
var array<label> swingLowTextArr = array.new_label(0)

//---------------------------------------------------------------------------------------------------------------------
// INITIALIZATION
//---------------------------------------------------------------------------------------------------------------------
if barstate.isfirst
    if showSwingOrderBlocksInput
        for i = 1 to 5
            swingOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))
    if showInternalOrderBlocksInput
        for i = 1 to 5
            internalOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))

atrMeasure = ta.atr(200)
volatilityMeasure = atrMeasure
highVolatilityBar = (high - low) >= (2 * volatilityMeasure)
parsedHigh = highVolatilityBar ? low : high
parsedLow = highVolatilityBar ? high : low

parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS - SMC
//---------------------------------------------------------------------------------------------------------------------
leg(int size) =>
    var leg = 0
    newLegHigh = high[size] > ta.highest(size)
    newLegLow = low[size] < ta.lowest(size)
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

startOfNewLeg(int currentLeg) =>
    ta.change(currentLeg) != 0

startOfBullishLeg(int currentLeg) =>
    ta.change(currentLeg) == +1

startOfBearishLeg(int currentLeg) =>
    ta.change(currentLeg) == -1

getCurrentStructure(int size, bool internal = false) =>
    currentLeg = leg(size)
    newPivot = startOfNewLeg(currentLeg)
    pivotLow = startOfBullishLeg(currentLeg)
    pivotHigh = startOfBearishLeg(currentLeg)
    
    if newPivot
        if pivotLow
            pivot p_ivot = internal ? internalLow : swingLow
            p_ivot.lastLevel := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed := false
            p_ivot.barTime := time[size]
            p_ivot.barIndex := bar_index[size]
        else
            pivot p_ivot = internal ? internalHigh : swingHigh
            p_ivot.lastLevel := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed := false
            p_ivot.barTime := time[size]
            p_ivot.barIndex := bar_index[size]
    [currentLeg, newPivot]

drawStructure(pivot p_ivot, string tag, color structureColor, bool internal = false) =>
    if showSwingLabelsInput and not na(p_ivot.currentLevel)
        lineStyle = internal ? line.style_dashed : line.style_solid
        labelSize = internal ? size.tiny : size.small
        labelStyle = structureColor == GREEN ? label.style_label_down : label.style_label_up
        labelPos = math.round(0.5 * (p_ivot.barIndex + bar_index))
        
        line.new(p_ivot.barTime, p_ivot.currentLevel, time, p_ivot.currentLevel, xloc=xloc.bar_time, color=structureColor, style=lineStyle, width=2)
        label.new(labelPos, p_ivot.currentLevel, tag, xloc=xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size=labelSize)

storeOrderBlock(pivot p_ivot, bool internal = false, int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)
        array<float> a_rray = na
        int parsedIndex = na
        if bias == BEARISH
            a_rray := parsedHighs.slice(p_ivot.barIndex, bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())
        else
            a_rray := parsedLows.slice(p_ivot.barIndex, bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())
        
        orderBlock o_rderBlock = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex), bias)
        array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
        
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

displayStructure(bool internal = false) =>
    pivot highPivot = internal ? internalHigh : swingHigh
    pivot lowPivot = internal ? internalLow : swingLow
    trend t_rend = internal ? internalTrend : swingTrend
    
    if not na(highPivot.currentLevel) and ta.crossover(close, highPivot.currentLevel) and not highPivot.crossed
        string tag = t_rend.bias == BEARISH ? "CHoCH" : "BOS"
        highPivot.crossed := true
        t_rend.bias := BULLISH
        
        if (internal and showInternalsInput) or (not internal and showStructureInput)
            drawStructure(highPivot, tag, GREEN, internal)
        
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrderBlock(highPivot, internal, BULLISH)
    
    if not na(lowPivot.currentLevel) and ta.crossunder(close, lowPivot.currentLevel) and not lowPivot.crossed
        string tag = t_rend.bias == BULLISH ? "CHoCH" : "BOS"
        lowPivot.crossed := true
        t_rend.bias := BEARISH
        
        if (internal and showInternalsInput) or (not internal and showStructureInput)
            drawStructure(lowPivot, tag, RED, internal)
        
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrderBlock(lowPivot, internal, BEARISH)

//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS - INSTITUTIONAL SWEEP
//---------------------------------------------------------------------------------------------------------------------
lineStyle(s) =>
    string result = line.style_solid
    if s == 'Solid'
        result := line.style_solid
    else if s == 'Dotted'
        result := line.style_dotted
    else
        result := line.style_dashed
    result

//---------------------------------------------------------------------------------------------------------------------
// UT BOT LOGIC
//---------------------------------------------------------------------------------------------------------------------
xATR = ta.atr(utATRPeriod)
nLoss = utKeyValue * xATR
srcUT = utUseHeikinAshi ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close) : close

var float xATRTrailingStop = 0.0
xATRTrailingStop := if srcUT > nz(xATRTrailingStop[1], 0) and srcUT[1] > nz(xATRTrailingStop[1], 0)
    math.max(nz(xATRTrailingStop[1]), srcUT - nLoss)
else if srcUT < nz(xATRTrailingStop[1], 0) and srcUT[1] < nz(xATRTrailingStop[1], 0)
    math.min(nz(xATRTrailingStop[1]), srcUT + nLoss)
else if srcUT > nz(xATRTrailingStop[1], 0)
    srcUT - nLoss
else
    srcUT + nLoss

var int pos = 0
pos := if srcUT[1] < nz(xATRTrailingStop[1], 0) and srcUT > nz(xATRTrailingStop[1], 0)
    1
else if srcUT[1] > nz(xATRTrailingStop[1], 0) and srcUT < nz(xATRTrailingStop[1], 0)
    -1
else
    nz(pos[1], 0)

ema_ut = ta.ema(srcUT, 1)
above = ta.crossover(ema_ut, xATRTrailingStop)
below = ta.crossover(xATRTrailingStop, ema_ut)

utBuy = srcUT > xATRTrailingStop and above
utSell = srcUT < xATRTrailingStop and below

plotshape(utBuy, title="UT Buy", text='Buy', style=shape.labelup, location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny)
plotshape(utSell, title="UT Sell", text='Sell', style=shape.labeldown, location=location.abovebar, color=color.red, textcolor=color.white, size=size.tiny)

//---------------------------------------------------------------------------------------------------------------------
// HULL MA LOGIC
//---------------------------------------------------------------------------------------------------------------------
n2ma = 2 * ta.wma(close, math.round(hullPeriod / 2))
nma = ta.wma(close, hullPeriod)
diff = n2ma - nma
sqn = math.round(math.sqrt(hullPeriod))

n2ma1 = 2 * ta.wma(close[1], math.round(hullPeriod / 2))
nma1 = ta.wma(close[1], hullPeriod)
diff1 = n2ma1 - nma1

hullMA = ta.wma(diff, sqn)
hullMA1 = ta.wma(diff1, sqn)
hullBullish = hullMA > hullMA1
hullBearish = hullMA < hullMA1

c1 = hullBullish ? color.green : color.red
plot(hullMA, color=c1, linewidth=2, title="HullMA")

//---------------------------------------------------------------------------------------------------------------------
// ORB LOGIC
//---------------------------------------------------------------------------------------------------------------------
t = time(timeframe.period, orbSession + ":1234567")
hide = timeframe.isintraday and timeframe.multiplier <= orbTimeMax
in_session = not na(t)
is_first = in_session and not in_session[1]

var float orb_high = na
var float orb_low = na

if is_first
    orb_high := high
    orb_low := low
else
    orb_high := orb_high[1]
    orb_low := orb_low[1]

if high > orb_high and in_session
    orb_high := high
if low < orb_low and in_session
    orb_low := low

orbBullishBreakout = ta.crossover(close, orb_high)
orbBearishBreakout = ta.crossunder(close, orb_low)

plot(hide ? orb_high : na, style=plot.style_line, color=orb_high[1] != orb_high ? na : color.green, title="ORB High", linewidth=1)
plot(hide ? orb_low : na, style=plot.style_line, color=orb_low[1] != orb_low ? na : color.red, title="ORB Low", linewidth=1)

//---------------------------------------------------------------------------------------------------------------------
// INSTITUTIONAL SWEEP LOGIC
//---------------------------------------------------------------------------------------------------------------------
pLow = ta.pivotlow(low, lbLeft, lbRight)
pHigh = ta.pivothigh(high, lbLeft, lbRight)

pLowVal = ta.valuewhen(not na(pLow), low[lbRight], 0)
pHighVal = ta.valuewhen(not na(pHigh), high[lbRight], 0)

prevLowIndex = ta.valuewhen(not na(pLow), bar_index[lbRight], 0)
prevHighIndex = ta.valuewhen(not na(pHigh), bar_index[lbRight], 0)

lp = ta.lowest(low, lbLeft)
hp = ta.highest(high, lbLeft)

highestClose = ta.highest(close, lbLeft)
lowestClose = ta.lowest(close, lbLeft)

bullishSFP = low < pLowVal and close > pLowVal and open > pLowVal and low == lp and lowestClose >= pLowVal
bearishSFP = high > pHighVal and close < pHighVal and open < pHighVal and high == hp and highestClose <= pHighVal

bullCond = bullishSFP[3] and (close > pLowVal) and (close[1] > pLowVal[1]) and (close[2] > pLowVal[2]) and bar_index >= bullSignalIndex + cooldownPeriod
bearCond = bearishSFP[3] and (close < pHighVal) and (close[1] < pHighVal[1]) and (close[2] < pHighVal[2]) and bar_index >= bearSignalIndex + cooldownPeriod

if high < swingLowVal and isSwingLowCheck
    swingLowCounter := swingLowCounter + 1

if low > swingHighVal and isSwingHighCheck
    swingHighCounter := swingHighCounter + 1

if ta.crossunder(close, swingLowVal) and isSwingLowCheck == false
    isSwingLowCheck := true
    swingLowCounter := 1

if ta.crossover(close, swingHighVal) and isSwingHighCheck == false
    isSwingHighCheck := true
    swingHighCounter := 1

if swingLowCounter == 5 and isSwingLowCheck
    stopPrintingLow := true
    isSwingLowCheck := false
    line.set_x2(lowLine, bar_index[4])

if swingHighCounter == 5 and isSwingHighCheck
    stopPrintingHigh := true
    isSwingHighCheck := false
    line.set_x2(highLine, bar_index[4])

if bullCond
    bullSignalIndex := bar_index
    bullLine := line.new(prevLowIndex, pLowVal, bar_index - 3, pLowVal, color=bullColor, width=bullWidth, style=lineStyle(bullStyle))

if bearCond
    bearSignalIndex := bar_index
    bearLine := line.new(prevHighIndex, pHighVal, bar_index - 3, pHighVal, color=bearColor, width=bearWidth, style=lineStyle(bearStyle))

if array.size(swingHighArr) >= 3
    label.delete(array.shift(swingHighArr))
    label.delete(array.shift(swingHighTextArr))

if array.size(swingLowArr) >= 3
    label.delete(array.shift(swingLowArr))
    label.delete(array.shift(swingLowTextArr))

if showSwing
    if stopPrintingHigh == false
        line.set_x2(highLine, bar_index + 5)
    if stopPrintingLow == false
        line.set_x2(lowLine, bar_index + 5)

if showSwing and not na(pHigh) and bearishSFP[lbRight] == false
    stopPrintingHigh := false
    swingHighVal := high[lbRight]
    line.delete(highLine)
    highLine := line.new(bar_index[lbRight], high[lbRight], bar_index + 10, high[lbRight], color=swingClr, width=2)
    swingHighLbl := label.new(bar_index[lbRight], high[lbRight], text="", yloc=yloc.abovebar, color=swingClr, textcolor=swingClr, style=label.style_triangledown, size=size.auto)
    swingHighLblTxt := label.new(bar_index[lbRight], high[lbRight], text="Swing\nH", yloc=yloc.abovebar, color=swingClr, textcolor=swingClr, style=label.style_none, size=size.small)
    array.push(swingHighArr, swingHighLbl)
    array.push(swingHighTextArr, swingHighLblTxt)

if showSwing and not na(pLow) and bullishSFP[lbRight] == false
    stopPrintingLow := false
    swingLowVal := low[lbRight]
    line.delete(lowLine)
    lowLine := line.new(bar_index[lbRight], low[lbRight], bar_index + 10, low[lbRight], color=swingClr, width=2)
    swingLowLbl := label.new(bar_index[lbRight], low[lbRight], text="", yloc=yloc.belowbar, color=swingClr, textcolor=swingClr, style=label.style_triangleup, size=size.auto)
    swingLowLblTxt := label.new(bar_index[lbRight], low[lbRight], text="Swing\nL", yloc=yloc.belowbar, color=swingClr, textcolor=swingClr, style=label.style_none, size=size.small)
    array.push(swingLowArr, swingLowLbl)
    array.push(swingLowTextArr, swingLowLblTxt)

plotshape(bullCond, text='Sweep', color=bullColor, textcolor=bullColor, location=location.belowbar, offset=-3)
plotshape(bearCond, text='Sweep', color=bearColor, textcolor=bearColor, location=location.abovebar, offset=-3)

//---------------------------------------------------------------------------------------------------------------------
// STRATEGY LOGIC - COMBINED SIGNALS
//---------------------------------------------------------------------------------------------------------------------
longCondition = utBuy and hullBullish and internalTrend.bias == BULLISH and bullCond
shortCondition = utSell and hullBearish and internalTrend.bias == BEARISH and bearCond

if longCondition
    strategy.entry("Long", strategy.long)

if shortCondition
    strategy.entry("Short", strategy.short)

if strategy.position_size > 0 and (utSell or hullBearish)
    strategy.close("Long")

if strategy.position_size < 0 and (utBuy or hullBullish)
    strategy.close("Short")

//---------------------------------------------------------------------------------------------------------------------
// EXECUTION - SMC UPDATES
//---------------------------------------------------------------------------------------------------------------------
parsedOpen = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? GREEN : RED
plotcandle(parsedOpen, high, low, close, color=candleColor, wickcolor=candleColor, bordercolor=candleColor)

// Update structures first
getCurrentStructure(swingsLengthInput, false)
getCurrentStructure(internalLengthInput, true)

// Then display structures - this must happen on every bar
if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput
    displayStructure(false)

//---------------------------------------------------------------------------------------------------------------------
// ALERTS
//---------------------------------------------------------------------------------------------------------------------
alertcondition(longCondition, "Long Signal", "Long Entry Signal Generated")
alertcondition(shortCondition, "Short Signal", "Short Entry Signal Generated")
alertcondition(utBuy, "UT Long", "UT Long Signal")
alertcondition(utSell, "UT Short", "UT Short Signal")
alertcondition(bullishSFP, "Bullish Sweep", "{{ticker}} Bullish Sweep, Price:{{close}}")
alertcondition(bearishSFP, "Bearish Sweep", "{{ticker}} Bearish Sweep, Price:{{close}}")

//---------------------------------------------------------------------------------------------------------------------
// END OF CODE - COPY UNTIL HERE
//-------------------------------------------------
